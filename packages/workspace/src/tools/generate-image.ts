import { AIGatewayProviderConfig } from "@quests/ai-gateway";
import { imageSize } from "image-size";
import mime from "mime-types";
import ms from "ms";
import { err, ok } from "neverthrow";
import path from "node:path";
import { dedent } from "radashi";
import { z } from "zod";

import { absolutePathJoin } from "../lib/absolute-path-join";
import { ensureRelativePath } from "../lib/ensure-relative-path";
import { generateImages } from "../lib/generate-images";
import { writeFileWithDir } from "../lib/write-file-with-dir";
import { getWorkspaceServerURL } from "../logic/server/url";
import { RelativePathSchema } from "../schemas/paths";
import { BaseInputSchema, TOOL_EXPLANATION_PARAM_NAME } from "./base";
import { createTool } from "./create-tool";

const INPUT_PARAMS = {
  filePath: "filePath",
  prompt: "prompt",
} as const;

export const GenerateImage = createTool({
  description: dedent`
    Generate an image using AI from a text description.

    Good for:
    - Illustrations, icons, concept art, stylistic visuals
    - "Make it look like X" requests where the exact pixels/style matter more than deterministic accuracy

    Bad for:
    - Data visualizations (bar/line charts, plots, histograms), tables, dashboards that can be generated by a script.

    IMPORTANT: SLOW and EXPENSIVE. Only use when:
    - User EXPLICITLY requests AI image generation (e.g., "generate an image of...", "create a picture of...")
    - User describes complex imagery clearly only achievable through AI (detailed scenes, photorealistic content, specific artistic styles)
    - Otherwise, ALWAYS confirm with user first before generating

    If unclear, default to text-based image formats that can be created with code, e.g. SVG, Canvas, Mermaid diagrams, etc.

    - ${INPUT_PARAMS.filePath}: relative path with filename WITHOUT extension (e.g., ./images/output). Extension will be added based on generated image type.
  `,
  execute: async ({ appConfig, input, model, signal }) => {
    const fixedPathResult = ensureRelativePath(input.filePath);
    if (fixedPathResult.isErr()) {
      return err(fixedPathResult.error);
    }
    const fixedPath = fixedPathResult.value;

    // Strip extension if mistakenly provided
    const parsedPath = path.parse(fixedPath);
    const pathWithoutExt = path.join(parsedPath.dir, parsedPath.name);

    const providerConfigs = appConfig.workspaceConfig.getAIProviderConfigs();
    const preferredProviderConfig = providerConfigs.find(
      (c) => c.id === model.params.providerConfigId,
    );

    if (!preferredProviderConfig) {
      return ok({
        errorMessage: "No AI provider found for current model.",
        errorType: "no-provider" as const,
        state: "failure" as const,
      });
    }

    try {
      const result = await generateImages({
        configs: providerConfigs,
        count: 1,
        preferredProviderConfig,
        prompt: input.prompt,
        signal,
        workspaceServerURL: getWorkspaceServerURL(),
      });

      if (result.isErr()) {
        return ok({
          errorMessage:
            "No AI provider with image generation capability is available.",
          errorType: "no-image-generation-capability" as const,
          state: "failure" as const,
        });
      }

      const { images, modelId, provider, usage } = result.value;

      const writtenImages = await Promise.all(
        images.map(async (image, index) => {
          const mimeExt = mime.extension(image.mediaType);
          // Fall back to png because most image models default to it
          const ext = typeof mimeExt === "string" ? mimeExt : "png";

          // Create unique filename for multiple images
          const filename =
            images.length > 1
              ? `${pathWithoutExt}-${index + 1}.${ext}`
              : `${pathWithoutExt}.${ext}`;

          const absolutePath = absolutePathJoin(appConfig.appDir, filename);
          const imageBuffer = Buffer.from(image.base64, "base64");

          await writeFileWithDir(absolutePath, imageBuffer, { signal });

          // Try to get image dimensions, but don't fail if it doesn't work
          let dimensions: { height?: number; width?: number } = {};
          try {
            const size = imageSize(imageBuffer);
            dimensions = {
              height: size.height,
              width: size.width,
            };
          } catch {
            // Gracefully handle if image-size fails
          }

          return {
            filePath: RelativePathSchema.parse(filename),
            ...dimensions,
            sizeBytes: imageBuffer.length,
          };
        }),
      );

      return ok({
        images: writtenImages,
        modelId,
        provider: {
          displayName: provider.displayName,
          id: provider.id,
          type: provider.type,
        },
        state: "success" as const,
        usage: {
          inputTokens: usage.inputTokens,
          outputTokens: usage.outputTokens,
          totalTokens: usage.totalTokens,
        },
      });
    } catch (error) {
      return ok({
        errorMessage: `Failed to generate image: ${error instanceof Error ? error.message : "Unknown error"}`,
        errorType: "generation-failed" as const,
        state: "failure" as const,
      });
    }
  },
  inputSchema: BaseInputSchema.extend({
    [INPUT_PARAMS.filePath]: z.string().meta({
      description: `Relative path including filename WITHOUT extension where the image(s) should be saved (e.g., ./output/image-name-here). Extension will be added automatically. Generate this after ${TOOL_EXPLANATION_PARAM_NAME}.`,
    }),
    [INPUT_PARAMS.prompt]: z.string().meta({
      description: "Detailed description of the image to generate",
    }),
  }),
  name: "generate_image",
  outputSchema: z.discriminatedUnion("state", [
    z.object({
      images: z.array(
        z.object({
          filePath: RelativePathSchema,
          height: z.number().optional(),
          sizeBytes: z.number(),
          width: z.number().optional(),
        }),
      ),
      modelId: z.string(),
      provider: AIGatewayProviderConfig.Schema.pick({
        displayName: true,
        id: true,
        type: true,
      }).meta({
        description:
          "A limited set of provider configuration details to display in the UI",
      }),
      state: z.literal("success"),
      usage: z.object({
        inputTokens: z.union([z.number(), z.nan()]).optional(),
        outputTokens: z.union([z.number(), z.nan()]).optional(),
        totalTokens: z.union([z.number(), z.nan()]).optional(),
      }),
    }),
    z.object({
      errorMessage: z.string(),
      errorType: z.enum([
        "no-provider",
        "no-image-generation-capability",
        "generation-failed",
      ]),
      state: z.literal("failure"),
    }),
  ]),
  readOnly: false,
  timeoutMs: ms("60 seconds"),
  toModelOutput: ({ output }) => {
    if (output.state === "failure") {
      return {
        type: "text",
        value: output.errorMessage,
      };
    }

    const imageCount = output.images.length;

    if (imageCount === 0) {
      return {
        type: "text",
        value: "No images were generated",
      };
    }

    const imageList = output.images
      .map((image) => {
        const size = `${Math.round(image.sizeBytes / 1024)}KB`;
        const dimensions =
          image.width && image.height ? `, ${image.width}x${image.height}` : "";
        return `${image.filePath} (${size}${dimensions})`;
      })
      .join("\n");

    if (imageCount === 1) {
      return {
        type: "text",
        value: `Successfully generated image and saved to ${imageList}`,
      };
    }

    return {
      type: "text",
      value: `Successfully generated ${imageCount} images:\n${imageList}`,
    };
  },
});
