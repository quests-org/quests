import { imageSize } from "image-size";
import mime from "mime-types";
import ms from "ms";
import { err, ok } from "neverthrow";
import fs from "node:fs/promises";
import path from "node:path";
import { dedent } from "radashi";
import { z } from "zod";

import { absolutePathJoin } from "../lib/absolute-path-join";
import { ensureRelativePath } from "../lib/ensure-relative-path";
import { executeError } from "../lib/execute-error";
import { formatBytes } from "../lib/format-bytes";
import { generateImages } from "../lib/generate-images";
import { normalizePath } from "../lib/normalize-path";
import { writeFileWithDir } from "../lib/write-file-with-dir";
import { getWorkspaceServerURL } from "../logic/server/url";
import { RelativePathSchema } from "../schemas/paths";
import {
  BaseInputSchema,
  ProviderOutputSchema,
  TOOL_EXPLANATION_PARAM_NAME,
  UsageOutputSchema,
} from "./base";
import { setupTool } from "./create-tool";

const INPUT_PARAMS = {
  filePath: "filePath",
  prompt: "prompt",
  sourceImages: "sourceImages",
} as const;

export const GenerateImage = setupTool({
  inputSchema: BaseInputSchema.extend({
    [INPUT_PARAMS.filePath]: z.string().meta({
      description: `Relative path including filename WITHOUT extension where the image(s) should be saved (e.g., ./output/image-name-here). Extension will be added automatically. Generate this after ${TOOL_EXPLANATION_PARAM_NAME}.`,
    }),
    [INPUT_PARAMS.prompt]: z.string().meta({
      description: "Detailed description of the image to generate",
    }),
    [INPUT_PARAMS.sourceImages]: z.array(z.string()).optional().meta({
      description:
        "Relative file paths to images used for image-to-image (img2img) conditioning. Use when the user wants to edit, transform, or use an existing image as a visual reference or style source.",
    }),
  }),
  name: "generate_image",
  outputSchema: z.discriminatedUnion("state", [
    z.object({
      images: z.array(
        z.object({
          filePath: RelativePathSchema,
          height: z.number().optional(),
          sizeBytes: z.number(),
          width: z.number().optional(),
        }),
      ),
      modelId: z.string(),
      provider: ProviderOutputSchema,
      state: z.literal("success"),
      usage: UsageOutputSchema,
    }),
    z.object({
      errorMessage: z.string(),
      errorType: z.enum(["api-call", "no-image-model", "provider-limitation"]),
      responseBody: z.string().optional(),
      state: z.literal("failure"),
    }),
  ]),
}).create({
  // cspell:ignore img2img, inpainting
  description: dedent`
    Generate an image using AI from a text description, or edit/composite existing images using img2img.

    Good for:
    - Illustrations, icons, concept art, stylistic visuals
    - Image editing: style transfer, inpainting, compositing, scene integration
    - Placing or integrating visual elements into a scene, especially when it requires understanding image content (e.g., locating objects, natural blending); scripts cannot interpret image content, so always use this tool for these tasks

    Bad for:
    - Data visualizations (charts, plots, dashboards) that can be generated by a script

    Calls an external AI image model (takes several seconds, uses image generation credits). Only use when the user explicitly requests image generation/editing, or when the task clearly requires it (photorealistic scenes, artistic composition, style transfer). Otherwise confirm first or default to code-based formats (SVG, Canvas, etc.).
  `,
  execute: async ({ appConfig, input, model, signal }) => {
    const fixedPathResult = ensureRelativePath(input.filePath);
    if (fixedPathResult.isErr()) {
      return err(fixedPathResult.error);
    }
    const fixedPath = fixedPathResult.value;

    // Strip extension if mistakenly provided
    const parsedPath = path.parse(fixedPath);
    const pathWithoutExt = normalizePath(
      path.join(parsedPath.dir, parsedPath.name),
    );

    let sourceImageBuffers: Buffer[] | undefined;
    if (input.sourceImages && input.sourceImages.length > 0) {
      sourceImageBuffers = await Promise.all(
        input.sourceImages.map((relativePath) => {
          const absolutePath = absolutePathJoin(appConfig.appDir, relativePath);
          return fs.readFile(absolutePath);
        }),
      );
    }

    const result = await generateImages({
      callingModel: model,
      configs: appConfig.workspaceConfig.getAIProviderConfigs(),
      count: 1,
      prompt: input.prompt,
      signal,
      sourceImages: sourceImageBuffers,
      workspaceConfig: appConfig.workspaceConfig,
      workspaceServerURL: getWorkspaceServerURL(),
    });

    if (result.isErr()) {
      const generateError = result.error;

      switch (generateError.type) {
        case "gateway-not-found-error": {
          return ok({
            errorMessage:
              "No AI provider with image generation capability is available.",
            errorType: "no-image-model" as const,
            state: "failure" as const,
          });
        }
        case "workspace-api-call-error": {
          return ok({
            errorMessage: generateError.message,
            errorType: "api-call" as const,
            responseBody: generateError.responseBody,
            state: "failure" as const,
          });
        }
        case "workspace-provider-limitation-error": {
          return ok({
            errorMessage: generateError.message,
            errorType: "provider-limitation" as const,
            state: "failure" as const,
          });
        }
        default: {
          generateError satisfies never;
          return executeError(JSON.stringify(generateError));
        }
      }
    }

    const { config, images, modelId, usage } = result.value;

    const writtenImages = await Promise.all(
      images.map(async (image, index) => {
        const mimeExt = mime.extension(image.mediaType);
        // Fall back to png because most image models default to it
        const ext = typeof mimeExt === "string" ? mimeExt : "png";

        // Create unique filename for multiple images
        const filename =
          images.length > 1
            ? `${pathWithoutExt}-${index + 1}.${ext}`
            : `${pathWithoutExt}.${ext}`;

        const absolutePath = absolutePathJoin(appConfig.appDir, filename);
        const imageBuffer = Buffer.from(image.base64, "base64");

        await writeFileWithDir(absolutePath, imageBuffer, { signal });

        // Try to get image dimensions, but don't fail if it doesn't work
        let dimensions: { height?: number; width?: number } = {};
        try {
          const size = imageSize(imageBuffer);
          dimensions = {
            height: size.height,
            width: size.width,
          };
        } catch {
          // Ignore failed image size calculation
        }

        return {
          filePath: RelativePathSchema.parse(filename),
          ...dimensions,
          sizeBytes: imageBuffer.length,
        };
      }),
    );

    return ok({
      images: writtenImages,
      modelId,
      provider: {
        displayName: config.displayName,
        id: config.id,
        type: config.type,
      },
      state: "success" as const,
      usage: {
        inputTokens: usage.inputTokens,
        outputTokens: usage.outputTokens,
        totalTokens: usage.totalTokens,
      },
    });
  },
  readOnly: false,
  timeoutMs: ms("2 minutes"),
  toModelOutput: ({ output }) => {
    if (output.state === "failure") {
      return {
        type: "text",
        value: output.errorMessage,
      };
    }

    const imageCount = output.images.length;

    if (imageCount === 0) {
      return {
        type: "text",
        value: "No images were generated",
      };
    }

    const imageList = output.images
      .map((image) => {
        const size = formatBytes(image.sizeBytes);
        const dimensions =
          image.width && image.height ? ` ${image.width}x${image.height}` : "";
        return `${image.filePath} ${size}${dimensions}`;
      })
      .join("\n");

    if (imageCount === 1) {
      return {
        type: "text",
        value: `Successfully generated image and saved to ${imageList}`,
      };
    }

    return {
      type: "text",
      value: `Successfully generated ${imageCount} images:\n${imageList}`,
    };
  },
});
