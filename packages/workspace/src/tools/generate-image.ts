import { generateImageWithProvider } from "@quests/ai-gateway";
import ms from "ms";
import { err, ok } from "neverthrow";
import { dedent, sift } from "radashi";
import { z } from "zod";

import { absolutePathJoin } from "../lib/absolute-path-join";
import { checkReminder } from "../lib/check-reminder";
import { ensureRelativePath } from "../lib/ensure-relative-path";
import { executeError } from "../lib/execute-error";
import { writeFileWithDir } from "../lib/write-file-with-dir";
import { getWorkspaceServerURL } from "../logic/server/url";
import { RelativePathSchema } from "../schemas/paths";
import { BaseInputSchema, TOOL_EXPLANATION_PARAM_NAME } from "./base";
import { createTool } from "./create-tool";

const INPUT_PARAMS = {
  filePath: "filePath",
  prompt: "prompt",
} as const;

export const GenerateImage = createTool({
  description: dedent`
    Generate an image from a text description.

    Good for:
    - Illustrations, icons, concept art, stylistic visuals
    - "Make it look like X" requests where the exact pixels/style matter more than deterministic accuracy

    Bad for:
    - Data visualizations (bar/line charts, plots, histograms), tables, dashboards that can be generated by a script.

    IMPORTANT: SLOW and EXPENSIVE. Only use when:
    - User EXPLICITLY requests image generation (e.g., "generate an image of...", "create a picture of...")
    - User describes complex imagery clearly only achievable through AI image generation (detailed scenes, photorealistic content, specific artistic styles)
    - Otherwise, ALWAYS confirm with user first before generating

    If unclear, default to code or text-based image generation, e.g. SVG, Canvas, etc.

    - ${INPUT_PARAMS.filePath}: relative path with filename (e.g., ./images/output.png)
  `,
  execute: async ({ appConfig, input, signal }) => {
    const fixedPathResult = ensureRelativePath(input.filePath);
    if (fixedPathResult.isErr()) {
      return err(fixedPathResult.error);
    }
    const fixedPath = fixedPathResult.value;

    const absolutePath = absolutePathJoin(appConfig.appDir, fixedPath);

    try {
      const providerConfigs = appConfig.workspaceConfig.getAIProviderConfigs();

      const result = await generateImageWithProvider({
        configs: providerConfigs,
        prompt: input.prompt,
        signal,
        workspaceServerURL: getWorkspaceServerURL(),
      });

      if (!result.ok) {
        return executeError({
          code: "no-image-generation-provider",
          message: dedent`
            No AI provider with image generation capability is registered. 
            Please add one of the following providers: OpenAI, Google (Gemini), OpenRouter, or Quests.
          `,
        });
      }

      const imageBuffer = Buffer.from(result.value.base64, "base64");
      await writeFileWithDir(absolutePath, imageBuffer, { signal });

      return ok({
        filePath: fixedPath,
        sizeBytes: imageBuffer.length,
      });
    } catch (error) {
      return executeError(
        `Failed to generate image: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  },
  inputSchema: BaseInputSchema.extend({
    [INPUT_PARAMS.filePath]: z.string().meta({
      description: `Relative path including filename where the image should be saved (e.g., ./images/output.png). Generate this after ${TOOL_EXPLANATION_PARAM_NAME}.`,
    }),
    [INPUT_PARAMS.prompt]: z.string().meta({
      description: "Detailed description of the image to generate",
    }),
  }),
  name: "generate_image",
  outputSchema: z.object({
    filePath: RelativePathSchema,
    sizeBytes: z.number(),
  }),
  readOnly: false,
  timeoutMs: ms("60 seconds"),
  toModelOutput: ({ output }) => {
    return {
      type: "text",
      value: sift([
        `Successfully generated image and saved to ${output.filePath} (${Math.round(output.sizeBytes / 1024)}KB)`,
        checkReminder(output.filePath),
      ]).join("\n\n"),
    };
  },
});
