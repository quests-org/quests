import { imageSize } from "image-size";
import mime from "mime-types";
import ms from "ms";
import { err, ok } from "neverthrow";
import path from "node:path";
import { dedent } from "radashi";
import { z } from "zod";

import { absolutePathJoin } from "../lib/absolute-path-join";
import { ensureRelativePath } from "../lib/ensure-relative-path";
import { executeError } from "../lib/execute-error";
import { formatBytes } from "../lib/format-bytes";
import { generateImages } from "../lib/generate-images";
import { normalizePath } from "../lib/normalize-path";
import { writeFileWithDir } from "../lib/write-file-with-dir";
import { getWorkspaceServerURL } from "../logic/server/url";
import { RelativePathSchema } from "../schemas/paths";
import {
  BaseInputSchema,
  ProviderOutputSchema,
  TOOL_EXPLANATION_PARAM_NAME,
  UsageOutputSchema,
} from "./base";
import { createTool } from "./create-tool";

const INPUT_PARAMS = {
  filePath: "filePath",
  prompt: "prompt",
} as const;

export const GenerateImage = createTool({
  description: dedent`
    Generate an image using AI from a text description.

    Good for:
    - Illustrations, icons, concept art, stylistic visuals
    - "Make it look like X" requests where the exact pixels/style matter more than deterministic accuracy

    Bad for:
    - Data visualizations (bar/line charts, plots, histograms), tables, dashboards that can be generated by a script.

    IMPORTANT: SLOW and EXPENSIVE. Only use when:
    - User EXPLICITLY requests AI image generation (e.g., "generate an image of...", "create a picture of...")
    - User describes complex imagery clearly only achievable through AI (detailed scenes, photorealistic content, specific artistic styles)
    - Otherwise, ALWAYS confirm with user first before generating

    If unclear, default to text-based image formats that can be created with code, e.g. SVG, Canvas, Mermaid diagrams, etc.

    - ${INPUT_PARAMS.filePath}: relative path with filename WITHOUT extension (e.g., ./images/output). Extension will be added based on generated image type.
  `,
  execute: async ({ appConfig, input, model, signal }) => {
    const fixedPathResult = ensureRelativePath(input.filePath);
    if (fixedPathResult.isErr()) {
      return err(fixedPathResult.error);
    }
    const fixedPath = fixedPathResult.value;

    // Strip extension if mistakenly provided
    const parsedPath = path.parse(fixedPath);
    const pathWithoutExt = normalizePath(
      path.join(parsedPath.dir, parsedPath.name),
    );

    const result = await generateImages({
      callingModel: model,
      configs: appConfig.workspaceConfig.getAIProviderConfigs(),
      count: 1,
      prompt: input.prompt,
      signal,
      workspaceConfig: appConfig.workspaceConfig,
      workspaceServerURL: getWorkspaceServerURL(),
    });

    if (result.isErr()) {
      const generateError = result.error;

      switch (generateError.type) {
        case "gateway-not-found-error": {
          return ok({
            errorMessage:
              "No AI provider with image generation capability is available.",
            errorType: "no-image-model" as const,
            state: "failure" as const,
          });
        }
        case "workspace-api-call-error": {
          return ok({
            errorMessage: generateError.message,
            errorType: "api-call" as const,
            responseBody: generateError.responseBody,
            state: "failure" as const,
          });
        }
        default: {
          generateError satisfies never;
          return executeError(JSON.stringify(generateError));
        }
      }
    }

    const { images, modelId, provider, usage } = result.value;

    const writtenImages = await Promise.all(
      images.map(async (image, index) => {
        const mimeExt = mime.extension(image.mediaType);
        // Fall back to png because most image models default to it
        const ext = typeof mimeExt === "string" ? mimeExt : "png";

        // Create unique filename for multiple images
        const filename =
          images.length > 1
            ? `${pathWithoutExt}-${index + 1}.${ext}`
            : `${pathWithoutExt}.${ext}`;

        const absolutePath = absolutePathJoin(appConfig.appDir, filename);
        const imageBuffer = Buffer.from(image.base64, "base64");

        await writeFileWithDir(absolutePath, imageBuffer, { signal });

        // Try to get image dimensions, but don't fail if it doesn't work
        let dimensions: { height?: number; width?: number } = {};
        try {
          const size = imageSize(imageBuffer);
          dimensions = {
            height: size.height,
            width: size.width,
          };
        } catch {
          // Ignore failed image size calculation
        }

        return {
          filePath: RelativePathSchema.parse(filename),
          ...dimensions,
          sizeBytes: imageBuffer.length,
        };
      }),
    );

    return ok({
      images: writtenImages,
      modelId,
      provider: {
        displayName: provider.displayName,
        id: provider.id,
        type: provider.type,
      },
      state: "success" as const,
      usage: {
        inputTokens: usage.inputTokens,
        outputTokens: usage.outputTokens,
        totalTokens: usage.totalTokens,
      },
    });
  },
  inputSchema: BaseInputSchema.extend({
    [INPUT_PARAMS.filePath]: z.string().meta({
      description: `Relative path including filename WITHOUT extension where the image(s) should be saved (e.g., ./output/image-name-here). Extension will be added automatically. Generate this after ${TOOL_EXPLANATION_PARAM_NAME}.`,
    }),
    [INPUT_PARAMS.prompt]: z.string().meta({
      description: "Detailed description of the image to generate",
    }),
  }),
  name: "generate_image",
  outputSchema: z.discriminatedUnion("state", [
    z.object({
      images: z.array(
        z.object({
          filePath: RelativePathSchema,
          height: z.number().optional(),
          sizeBytes: z.number(),
          width: z.number().optional(),
        }),
      ),
      modelId: z.string(),
      provider: ProviderOutputSchema,
      state: z.literal("success"),
      usage: UsageOutputSchema,
    }),
    z.object({
      errorMessage: z.string(),
      errorType: z.enum(["api-call", "no-image-model"]),
      responseBody: z.string().optional(),
      state: z.literal("failure"),
    }),
  ]),
  readOnly: false,
  timeoutMs: ms("2 minutes"),
  toModelOutput: ({ output }) => {
    if (output.state === "failure") {
      return {
        type: "text",
        value: output.errorMessage,
      };
    }

    const imageCount = output.images.length;

    if (imageCount === 0) {
      return {
        type: "text",
        value: "No images were generated",
      };
    }

    const imageList = output.images
      .map((image) => {
        const size = formatBytes(image.sizeBytes);
        const dimensions =
          image.width && image.height ? ` ${image.width}x${image.height}` : "";
        return `${image.filePath} ${size}${dimensions}`;
      })
      .join("\n");

    if (imageCount === 1) {
      return {
        type: "text",
        value: `Successfully generated image and saved to ${imageList}`,
      };
    }

    return {
      type: "text",
      value: `Successfully generated ${imageCount} images:\n${imageList}`,
    };
  },
});
