import { AIGatewayProviderConfig, generateImages } from "@quests/ai-gateway";
import mime from "mime-types";
import ms from "ms";
import { err, ok } from "neverthrow";
import path from "node:path";
import { dedent } from "radashi";
import { z } from "zod";

import { absolutePathJoin } from "../lib/absolute-path-join";
import { ensureRelativePath } from "../lib/ensure-relative-path";
import { executeError } from "../lib/execute-error";
import { writeFileWithDir } from "../lib/write-file-with-dir";
import { getWorkspaceServerURL } from "../logic/server/url";
import { RelativePathSchema } from "../schemas/paths";
import { BaseInputSchema, TOOL_EXPLANATION_PARAM_NAME } from "./base";
import { createTool } from "./create-tool";

const INPUT_PARAMS = {
  filePath: "filePath",
  prompt: "prompt",
} as const;

export const GenerateImage = createTool({
  description: dedent`
    Generate an image using AI from a text description.

    Good for:
    - Illustrations, icons, concept art, stylistic visuals
    - "Make it look like X" requests where the exact pixels/style matter more than deterministic accuracy

    Bad for:
    - Data visualizations (bar/line charts, plots, histograms), tables, dashboards that can be generated by a script.

    IMPORTANT: SLOW and EXPENSIVE. Only use when:
    - User EXPLICITLY requests AI image generation (e.g., "generate an image of...", "create a picture of...")
    - User describes complex imagery clearly only achievable through AI (detailed scenes, photorealistic content, specific artistic styles)
    - Otherwise, ALWAYS confirm with user first before generating

    If unclear, default to text-based image formats that can be created with code, e.g. SVG, Canvas, Mermaid diagrams, etc.

    - ${INPUT_PARAMS.filePath}: relative path with filename WITHOUT extension (e.g., ./images/output). Extension will be added based on generated image type.
  `,
  execute: async ({ appConfig, input, model, signal }) => {
    const fixedPathResult = ensureRelativePath(input.filePath);
    if (fixedPathResult.isErr()) {
      return err(fixedPathResult.error);
    }
    const fixedPath = fixedPathResult.value;

    // Strip extension if mistakenly provided
    const parsedPath = path.parse(fixedPath);
    const pathWithoutExt = path.join(parsedPath.dir, parsedPath.name);

    const providerConfigs = appConfig.workspaceConfig.getAIProviderConfigs();
    const preferredProviderConfig = providerConfigs.find(
      (c) => c.id === model.params.providerConfigId,
    );

    if (!preferredProviderConfig) {
      return executeError({
        code: "no-image-generation-provider",
        message:
          "No AI provider with image generation capability is available.",
      });
    }

    try {
      const result = await generateImages({
        configs: providerConfigs,
        count: 1,
        preferredProviderConfig,
        prompt: input.prompt,
        signal,
        workspaceServerURL: getWorkspaceServerURL(),
      });

      if (!result.ok) {
        return executeError({
          code: "no-image-generation-provider",
          message:
            "No AI provider with image generation capability is available.",
        });
      }

      const { images, modelId, provider, usage } = result.value;

      const writtenImages = await Promise.all(
        images.map(async (image, index) => {
          const mimeExt = mime.extension(image.mediaType);
          // Fall back to png because most image models default to it
          const ext = typeof mimeExt === "string" ? mimeExt : "png";

          // Create unique filename for multiple images
          const filename =
            images.length > 1
              ? `${pathWithoutExt}-${index + 1}.${ext}`
              : `${pathWithoutExt}.${ext}`;

          const absolutePath = absolutePathJoin(appConfig.appDir, filename);
          const imageBuffer = Buffer.from(image.base64, "base64");

          await writeFileWithDir(absolutePath, imageBuffer, { signal });

          return {
            filePath: RelativePathSchema.parse(filename),
            sizeBytes: imageBuffer.length,
          };
        }),
      );

      return ok({
        images: writtenImages,
        modelId,
        provider: {
          displayName: provider.displayName,
          id: provider.id,
          type: provider.type,
        },
        usage: {
          inputTokens: usage.inputTokens,
          outputTokens: usage.outputTokens,
          totalTokens: usage.totalTokens,
        },
      });
    } catch (error) {
      return executeError(
        `Failed to generate image: ${error instanceof Error ? error.message : "Unknown error"}`,
      );
    }
  },
  inputSchema: BaseInputSchema.extend({
    [INPUT_PARAMS.filePath]: z.string().meta({
      description: `Relative path including filename WITHOUT extension where the image(s) should be saved (e.g., ./output/image-name-here). Extension will be added automatically. Generate this after ${TOOL_EXPLANATION_PARAM_NAME}.`,
    }),
    [INPUT_PARAMS.prompt]: z.string().meta({
      description: "Detailed description of the image to generate",
    }),
  }),
  name: "generate_image",
  outputSchema: z.object({
    images: z.array(
      z.object({
        filePath: RelativePathSchema,
        sizeBytes: z.number(),
      }),
    ),
    modelId: z.string(),
    provider: AIGatewayProviderConfig.Schema.pick({
      displayName: true,
      id: true,
      type: true,
    }).meta({
      description:
        "A limited set of provider configuration details to display in the UI",
    }),
    usage: z.object({
      inputTokens: z.union([z.number(), z.nan()]).optional(),
      outputTokens: z.union([z.number(), z.nan()]).optional(),
      totalTokens: z.union([z.number(), z.nan()]).optional(),
    }),
  }),
  readOnly: false,
  timeoutMs: ms("60 seconds"),
  toModelOutput: ({ output }) => {
    const imageCount = output.images.length;

    if (imageCount === 0) {
      return {
        type: "text",
        value: "No images were generated",
      };
    }

    const imageList = output.images
      .map(
        (image) =>
          `${image.filePath} (${Math.round(image.sizeBytes / 1024)}KB)`,
      )
      .join("\n");

    if (imageCount === 1) {
      return {
        type: "text",
        value: `Successfully generated image and saved to ${imageList}`,
      };
    }

    return {
      type: "text",
      value: `Successfully generated ${imageCount} images:\n${imageList}`,
    };
  },
});
